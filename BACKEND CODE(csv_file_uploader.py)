import tkinter as tk
from tkinter import filedialog, messagebox
import pandas as pd
import pickle
import numpy as np
import pennylane as qml
from sklearn.metrics import classification_report
import matplotlib.pyplot as plt

# Load the trained model parameters from a pickle file
def load_model(filename=r"C:\Users\aman\quantum_model.pkl"):
    with open(filename, 'rb') as f:
        params = pickle.load(f)
    print(f"Model loaded from {filename}")
    return params

# Define the quantum device and circuit
def create_circuit(num_qubits):
    dev = qml.device('default.qubit', wires=num_qubits)

    @qml.qnode(dev)
    def circuit(x, weights):
        for i in range(len(x)):
            if i < num_qubits:  # Ensure we only map to available qubits
                qml.RX(x[i], wires=i)

        for i in range(num_qubits):
            qml.RY(weights[i], wires=i)  # Variational parameter

        # Example of CNOT gates
        for i in range(num_qubits - 1):
            qml.CNOT(wires=[i, i + 1])

        return [qml.expval(qml.PauliZ(i)) for i in range(num_qubits)]
    
    return circuit

# Process the uploaded CSV file
def process_csv(file_path):
    # Load the CSV data
    data = pd.read_csv(file_path)
    
    # Assuming the last column is the target (class label) and the rest are features
    X = data.iloc[:, :-1].values  # All columns except the last one as features
    y = data.iloc[:, -1].values    # The last column as the target
    
    # Load model parameters
    global dev_params, circuit
    dev_params = load_model(r"C:\Users\aman\quantum_model.pkl")  # Update the path if needed
    num_qubits = min(X.shape[1], 4)  # Number of qubits based on features
    circuit = create_circuit(num_qubits)

    # Make predictions for each sample
    predictions = []
    for x in X:
        pred = circuit(x, dev_params)  # Get the prediction from the quantum circuit
        pred_value = pred[0]  # Extract the expectation value
        pred_label = np.sign(pred_value)  # Get the class label based on the sign of the prediction
        predictions.append(pred_label)

    # Print and display the results
    print("Predictions:", predictions)
    print(classification_report(y, predictions))

    # Plot results
    plt.figure(figsize=(10, 5))
    plt.hist(predictions, bins=np.arange(-1, 2) - 0.5, edgecolor='black', align='mid')
    plt.title('Prediction Distribution')
    plt.xlabel('Class Labels')
    plt.ylabel('Frequency')
    plt.xticks([-1, 0, 1])
    plt.grid(axis='y')
    plt.show()

    # Calculate accuracy
    accuracy = np.mean(np.array(predictions) == y)
    print(f'Accuracy: {accuracy * 100:.2f}%')

    # Plot accuracy
    plt.figure(figsize=(8, 4))
    plt.bar(['Accuracy'], [accuracy], color='blue')
    plt.ylim(0, 1)
    plt.title('Model Accuracy')
    plt.ylabel('Accuracy')
    plt.show()

# Function to select file
def select_file():
    file_path = filedialog.askopenfilename(filetypes=[("CSV Files", "*.csv")])
    if file_path:
        process_csv(file_path)

# Create the GUI
root = tk.Tk()
root.title("CSV File Uploader")
root.geometry("300x150")

upload_button = tk.Button(root, text="Upload CSV", command=select_file)
upload_button.pack(expand=True)

# Run the application
root.mainloop()
